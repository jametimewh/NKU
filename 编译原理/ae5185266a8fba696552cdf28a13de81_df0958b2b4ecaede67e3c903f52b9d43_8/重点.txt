https://www.doczj.com/doc/7a9700730.html
词法分析：
----词法单元（不同类型词法单元属性值）
----双缓冲技术
----哨兵
----正则表达式（无法描述平衡或嵌套的结构，只能表示有限的重复和一个给定结构的无限重复）
----词法单元识别算法
------------状态转换图及其实现（fail函数的实现比较重要；else state = fail（））

----词法分析器的构造
------------自动机可以用状态转换图表示，如何构造自动机，直接用状态转化图（不含011子串的0、1串，能被3整除的二进制串）
------------Thompson构造法：正则表达式---NFA
------------子集构造法：NFA---DFA（两者差别）
------------最小化DFA（什么叫等价）

https://blog.csdn.net/weixin_56462041/article/details/127460777


语法分析：
----上下文无关文法CFG
------------推导：句型和句子；推导；推导符号（包含最左推导和最右推导）；最左句型；语法分析树和推导的对应关系
------------文法对比：正则表达式（三型文法）能表达的都能有上下文无关文法（二型文法）表示；为什么还需要正则表达式；
------------NFA转CFG
------------CFG的难点（手工设计，难以自动化）
------------CFG修改（除错 | 重写满足特殊要求） 
--------------------二义性（if else ：else和距离最近的if匹配； 重点在于多个最左最右推导）
--------------------左递归（如何消除？直接左递归 & 间接左递归）
--------------------ε产生式（一点不难，把ε的这个产生式直接代入置换掉就好了）
--------------------消除回路（除了开始符号的ε产生式，其它的所有产生式都要加入终结符T）
--------------------左公因子提取（提取出来改写产生式即可； 为什么要提取呢？）
------------CFG的优点(精确易懂；易于分析；易于修改；层次结构)和缺点（存在无法描述的语言结构）

----自顶向下语法分析
------------递归下降语法分析（DFS回溯；而且难以报告准确的错误位置；不确定性；编程实现）
------------非递归预测语法分析
--------------------FIRST集合；FOLLOW集合（二次扫描算法）
--------------------预测分析表的构造M[X , a]（针对每个产生式去看产生式右侧的FIRST集合）
--------------------LL(1)文法（文法特性：无二义性，无左递归，无左公因子，不然有多重定义项）
--------------------预测分析器运行方法（输入栈和符号栈）
--------------------非递归预测分析方法
--------------------预测分析法错误恢复（发生错误的两种情况；）
----------------------------恐慌模式（三种错误恢复手段；同步集即非终结符的FOLLOW集）
----------------------------短语层次的错误分析（就是在预测分析表的空位填入错误处理函数）

----自底向上语法分析
------------句柄（定义：非形式定义，形式定义；右边是终结符;二义性情况）
------------移入-归约语法分析技术（如何定位句柄；选哪个产生式归约；用栈进行实现；四个动作）
------------LR分析（这个名字的含义：其中R代表构造一个最右推导的逆过程；由总控程序和分析表组成，还有一个输入符号串和一个状态栈；分析表是LR分析器的核心，由分析动作表和状态转换表组成）
--------------------LR(0)分析表的构造（可行前缀概念：不含句柄后任何符号；什么是规范句型；可行前缀和句柄的关系；LR(0)项目；后继项目）
----------------------------写出文法G的增广文法G'
----------------------------写出G'初始状态I0，根据开始符号的基本项目S'->`S，构造I0项目集合
----------------------------根据GO函数和CLOSURE求其它的状态集
----------------------------构建识别可行前缀的DFA
----------------------------判断项目集规范族有没有冲突项目（什么是冲突项目），没有的话就是LR(0)语法。
----------------------------根据DFA构建ACTION表和GOTO表（移入项目分为终结符和非终结符；归约项目；接受项目）
--------------------SLR(1)分析表的构造（提出原因；解决冲突的办法：归约项目找FOLLOW集，移入项目找圆点后面FIRST集合，两两不相交才是SLR(1)文法）
----------------------------写出文法G的增广文法G'
----------------------------写出G'初始状态I0，根据开始符号的基本项目S'->`S，构造I0项目集合
----------------------------根据GO函数和CLOSURE求其它的状态集
----------------------------构建识别可行前缀的DFA
----------------------------计算冲突项目的FOLLOW集和FIRST集，如果两两不相交则为SLR（1）文法
----------------------------根据DFA构建ACTION表和GOTO表（移入项目分为终结符和非终结符；归约项目；接受项目；所有项目根据FIRST集和FOLLOW集构建）
--------------------LR(1)分析表的构造（提出原因；展望符的作用：归约时有用；展望符的集合是FOLLOW集的真子集：必要不充分； 构建LR(1)项目集规范族：[A->α·Bβ,a];）
----------------------------写出文法G的增广文法G'
----------------------------写出G'初始状态I0，根据开始符号的基本项目S'->`S，构造I0项目集合,注意CLOSURE计算方法有些许不同，需要考虑展望符。
----------------------------根据GO函数和CLOSURE求其它的状态集（状态集中核心项相同可以合并）
----------------------------构建识别可行前缀的DFA
----------------------------判断项目集规范族有没有冲突项目（什么是冲突项目），没有的话就是LR(1)语法。
----------------------------根据DFA构建ACTION表和GOTO表（移入项目分为终结符和非终结符；归约项目需要根据展望符；接受项目；）
----------------------------这样的分析表如果没有多重定义的元素，就成为规范LR(1)分析表，这个文法称为LR(1)文法
--------------------LALR(1)分析表的构造（提出原因,LR(1)太大了；LALR分析法和别的文法比较；实现方式：基于LR(1)分析表；同心集的概念；）
----------------------------先构造LR(1)的项目集族C = {I0 , I1 , I2 , ...... , In}
----------------------------合并所有同心集形成C' = {J0 , J1 , ......,Jm}是新的项目集族
----------------------------根据C'构建ACTION表（移进项目；归约项目看展望符；接受项目）和GOTO表（同心集的GO转换函数也是同心集，只要找到对应的即可）
----------------------------判断是否冲突，如果不冲突就是LALR分析表，即为LALR(1)文法
----------------------------LALR文法在输入串正确时和不正确时和LR文法相比；都能指出输入串错误位置。
----------------------------ACTION表的压缩（一行:per state---->一个列表）
----------------------------GOTO表的压缩(一列:per Nonterminator----->一个列表)
--------------------二义性文法可以使用吗（不可以，至少LR不可以，会有移进归约冲突这些，但是对于特殊优化情况有用）
--------------------LR分析器错误处理（不同文法错误处理不完全一样；Panic模式的实现；短语级模式的实现）



语法制导翻译
----语法制导翻译概述（语义分析器干啥；SDT定义是啥；两种具体形式，区别？）
----语法制导定义SDD（定义是什么；属性的表示；属性分类；受控副作用；具体表示：一张表）
------------属性的特点（终结符，非终结符的文法开始符号，综合属性和继承属性之间的关系）
------------SDD求值（注释分析树是什么？属性依赖图怎么求，虚拟属性也要画；拓扑排序；）
------------S属性和L属性SDD（定义是什么；L属性使用的特点；S属性和L属性关系;应用：抽象语法树：两种节点，如何画，如何写语义规则；）
------------SDT（定义：具体化；S-SDD：后缀翻译，产生式内部有语义动作；L-SDD：综合属性，继承属性；如何实现两种SDD；根据语法分析执行：3种）
------------区分SDD，SDT，（LL，递归下降分析，LR）它们之间的关系，不能随意绑定。


中间代码生成
----中间代码生成概述（定义；实现方法；好处）
----类型检查（确定运行时行为；翻译时的应用：4；）
------------类型表达式（表达类型；基本类型；类型构造符；5种复杂类型；图表示法：五种复杂类型；）
------------类型等价（结构等价；名等价）
------------类型的结构（可以用语法分析出来，当然指的是复杂类型结构）
------------类型检查（两个任务）
------------类型转换（类型综合和类型推导）
----中间表示
------------概述（优缺点；两种表示法）
------------抽象语法树（赋值；不归约）
------------DAG（AST的变体；用途；与语法树区别；真的是所有节点都重复利用吗？DAG的值编码）
------------三地址代码（定义；与AST，DAG的关系；地址；指令：过程调用；指定标号：符号标号，位置号；具体实现：三类）
----------------------------四元式（表的形式或者列出来；四个字段）
----------------------------三元式（避免引入临时变量；获取变量值位置）
----------------------------间接三元式（指针列表）
----------------------------三种实现比较（优缺点：四元式，三元式，间接三元式）
----声明语句
------------概述（有几类；如何实际写入SDT；数组；记录和类）
----赋值语句
------------
----控制流（先理解代码结构；再用SDD表示;各种类型的控制流语句；.code,.next,gen(),Label(),newlabel()）
----回填（目的；三个函数；SDD如何实现；布尔表达式回填；控制流语句回填）
----Switch
----过程调用


代码优化：
----基本块和流图（基本块划分；流图构造；循环）
----基本块的几种优化（局部公共子表达式；死代码消除；不能优化的情况；代数恒等式）

















