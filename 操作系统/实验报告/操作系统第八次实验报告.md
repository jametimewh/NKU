<p style='text-align:center;font-size:20px'>
    操作系统第六次实验报告
</p>
<p style='text-align:center;font-size:20px'>
    Write a c program to implement product and consumer problem using multi-threads
</p>

<p style='text-align:center;font-size:18px'>
    2212534 魏思诚
</p>


## 实验要求:

1. Write a c/c++ program 
2. To implement product and consumer problem using multi-threads
   1. 采⽤多线程实现⽣产者消费者问题
3. GCC

### 	具体要求:

1. 严格按时序输出每个生产者、消费者的行为，其中包括生产产品 k、消费 产品 k、进入临界区、存入产品、取出产品、离开临界区；
2. 需要考虑边界（某生产者生产第 K 个产品后所有生产者结束；某消费者 消费第 K 个产品后所有消费者结束； 
3. 需要考虑随机函数，生产者生产时需要一个随机时间；消费者消费时也 需要一个随机时间；
4. 编号：无论生产者还是消费者都需要有编号；产品同样也需要编号；缓 冲区的各个产品项也需要有编号； 
5. 输出形式可以采用标准输出、图形动态显示及同时文字记录输出等方式， 无论是生产者还是消费者，其主要输出内容如下： a) 进入临界区前，输出某某编号（生产者/消费者）线程准备进入临界 区 b) 进入临界区后，输出某某编号（生产者/消费者）线程已进入临界区 c) 离开临界区后，输出某某编号（生产者/消费者）线程已离开临界区 d) 生产者生产一个产品时，需要输出产品信息； e) 生产者将产品放入缓冲区时，需要输出相关信息； f) 消费者将产品从缓冲区取出时，需要输出相关信息； g) 消费者消费一个产品时，需要输出产品信息； 6) *不能出现竞态 7) **不能出现忙等待

## 实验步骤:

1. Install GCC Software Collection

   `sudo apt-get install build-essential`

   ![image-20241025140933276](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20241025140933276.png)

2. 编写生产者与消费者问题的代码:

   1. 临界区控制:
      - 使用`mutex mtx`和`unique_lock`保证生产者和消费者进入临界区时的互斥访问。生产者和消费者在访问共享资源（缓冲区`buffer`）时，使用锁来确保只有一个线程可以进入临界区，从而避免多个线程同时修改缓冲区造成的数据不一致问题。
      - 每次进入和离开临界区时，输出对应的生产者或消费者编号，这样便可以清晰地按顺序记录每个线程的行为。
   2. 条件变量:
      - 使用两个条件变量`cv_producer`和`cv_consumer`分别用于控制生产者和消费者的行为：
        - `cv_producer`：生产者在缓冲区已满时进入等待状态。只有在缓冲区有空间时才允许生产者继续生产。
        - `cv_consumer`：消费者在缓冲区为空时进入等待状态。只有在缓冲区有产品时才允许消费者继续消费。
      - 通过条件变量的`wait`函数，避免了忙等待情况，即线程在条件不满足时进入等待状态，而不是一直在占用CPU资源循环检查条件。
   3. 随机延迟:
      - 在生产和消费过程中，`this_thread::sleep_for(chrono::milliseconds(dist(gen)))`为生产者和消费者线程添加了一个随机的等待时间，以模拟生产和消费的实际过程。随机延迟不仅增加了代码的真实感，还避免了每个线程在临界区的操作过于集中，从而减轻了竞争压力。
   4. 生产和消费的边界条件:
      - 设置了`MAX_PRODUCTS`作为边界条件，确保生产者在生产到指定的数量后停止生产。这意味着在达到最大生产数后，生产者会退出，不会再向缓冲区放入新的产品。
      - 消费者在检测到所有产品都被消费完毕（即缓冲区为空且生产已达到上限）后，也会退出。这些条件确保了线程在达到终止条件时自动结束，不会进入死循环。
   5. 缓冲区的使用:
      - 使用`queue<int>`作为缓冲区来存储产品，每个产品用一个编号来标识。生产者在缓冲区未满时将产品放入缓冲区，并输出产品编号。消费者在缓冲区不为空时从缓冲区取出产品，同样输出产品编号。
      - 通过队列的数据结构，能够实现先进先出的缓冲管理机制，使得产品的生产和消费顺序得以保证。
   6. 无竞态条件:
      - 程序通过锁和条件变量严格控制了生产者和消费者对缓冲区的访问，确保临界区的资源共享是安全的。每次访问临界区时，只有一个线程可以访问并完成操作，避免了竞态条件的发生。
   7. 避免忙等待:
      - 通过条件变量的`wait`机制实现条件等待，线程在等待时并不会消耗CPU资源。这样避免了忙等待，即避免线程通过不停循环来检查条件是否满足。

   ```C++
   #include <iostream>
   #include <thread>
   #include <mutex>
   #include <condition_variable>
   #include <queue>
   #include <chrono>
   #include <random>
   
   using namespace std;
   
   const int BUFFER_SIZE = 5;  // 缓冲区大小
   const int MAX_PRODUCTS = 10;  // 生产和消费的产品总数
   int productCounter = 0;  // 产品编号计数器
   
   mutex mtx;
   condition_variable cv_producer, cv_consumer;
   queue<int> buffer;  // 缓冲区队列
   
   // 随机数生成器
   random_device rd;
   mt19937 gen(rd());
   uniform_int_distribution<> dist(100, 500);
   
   void produce(int producerID) {
       while (true) {
           this_thread::sleep_for(chrono::milliseconds(dist(gen)));  // 模拟生产时间
   
           unique_lock<mutex> lock(mtx);
           cout << "生产者 " << producerID << " 准备进入临界区\n";
           cv_producer.wait(lock, [] { return buffer.size() < BUFFER_SIZE; });
   
           // 临界区 - 生产产品
           int productID = ++productCounter;
           cout << "生产者 " << producerID << " 已进入临界区，生产产品 " << productID << endl;
           
           // 将产品放入缓冲区
           buffer.push(productID);
           cout << "生产者 " << producerID << " 将产品 " << productID << " 存入缓冲区\n";
   
           cout << "生产者 " << producerID << " 离开临界区\n";
   
           cv_consumer.notify_all();  // 通知消费者
           if (productCounter >= MAX_PRODUCTS) break;  // 达到最大产品数则结束生产
       }
   }
   
   void consume(int consumerID) {
       while (true) {
           this_thread::sleep_for(chrono::milliseconds(dist(gen)));  // 模拟消费时间
   
           unique_lock<mutex> lock(mtx);
           cout << "消费者 " << consumerID << " 准备进入临界区\n";
           cv_consumer.wait(lock, [] { return !buffer.empty(); });
   
           // 临界区 - 消费产品
           int productID = buffer.front();
           buffer.pop();
           cout << "消费者 " << consumerID << " 已进入临界区，取出产品 " << productID << endl;
   
           cout << "消费者 " << consumerID << " 消费产品 " << productID << endl;
           cout << "消费者 " << consumerID << " 离开临界区\n";
   
           cv_producer.notify_all();  // 通知生产者
   
           if (productCounter >= MAX_PRODUCTS && buffer.empty()) break;  // 达到最大产品数并消费完所有产品则结束消费
       }
   }
   
   int main() {
       thread producers[] = { thread(produce, 1), thread(produce, 2) };
       thread consumers[] = { thread(consume, 1), thread(consume, 2) };
   
       for (auto& p : producers) p.join();
       for (auto& c : consumers) c.join();
   
       cout << "生产和消费过程结束。" << endl;
       return 0;
   }
   ```

3. 编译与运行

   在终端输入:

   `g++ -std=c++11 -pthread producer_consumer.cpp -o producer_consumer && ./producer_consumer`

   ![image-20241108143156433](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20241108143156433.png)

   ```c++
   消费者 2 准备进入临界区
   消费者 1 准备进入临界区
   生产者 1 准备进入临界区
   生产者 1 已进入临界区，生产产品 1
   生产者 1 将产品 1 存入缓冲区
   生产者 1 离开临界区
   消费者 1 已进入临界区，取出产品 1
   消费者 1 消费产品 1
   消费者 1 离开临界区
   生产者 2 准备进入临界区
   生产者 2 已进入临界区，生产产品 2
   生产者 2 将产品 2 存入缓冲区
   生产者 2 离开临界区
   消费者 2 已进入临界区，取出产品 2
   消费者 2 消费产品 2
   消费者 2 离开临界区
   生产者 1 准备进入临界区
   生产者 1 已进入临界区，生产产品 3
   生产者 1 将产品 3 存入缓冲区
   生产者 1 离开临界区
   消费者 2 准备进入临界区
   消费者 2 已进入临界区，取出产品 3
   消费者 2 消费产品 3
   消费者 2 离开临界区
   生产者 2 准备进入临界区
   生产者 2 已进入临界区，生产产品 4
   生产者 2 将产品 4 存入缓冲区
   生产者 2 离开临界区
   消费者 2 准备进入临界区
   消费者 2 已进入临界区，取出产品 4
   消费者 2 消费产品 4
   消费者 2 离开临界区
   消费者 1 准备进入临界区
   生产者 1 准备进入临界区
   生产者 1 已进入临界区，生产产品 5
   生产者 1 将产品 5 存入缓冲区
   生产者 1 离开临界区
   消费者 1 已进入临界区，取出产品 5
   消费者 1 消费产品 5
   消费者 1 离开临界区
   生产者 2 准备进入临界区
   生产者 2 已进入临界区，生产产品 6
   生产者 2 将产品 6 存入缓冲区
   生产者 2 离开临界区
   消费者 2 准备进入临界区
   消费者 2 已进入临界区，取出产品 6
   消费者 2 消费产品 6
   消费者 2 离开临界区
   消费者 1 准备进入临界区
   生产者 2 准备进入临界区
   生产者 2 已进入临界区，生产产品 7
   生产者 2 将产品 7 存入缓冲区
   生产者 2 离开临界区
   消费者 1 已进入临界区，取出产品 7
   消费者 1 消费产品 7
   消费者 1 离开临界区
   生产者 1 准备进入临界区
   生产者 1 已进入临界区，生产产品 8
   生产者 1 将产品 8 存入缓冲区
   生产者 1 离开临界区
   生产者 2 准备进入临界区
   生产者 2 已进入临界区，生产产品 9
   生产者 2 将产品 9 存入缓冲区
   生产者 2 离开临界区
   消费者 2 准备进入临界区
   消费者 2 已进入临界区，取出产品 8
   消费者 2 消费产品 8
   消费者 2 离开临界区
   消费者 1 准备进入临界区
   消费者 1 已进入临界区，取出产品 9
   消费者 1 消费产品 9
   消费者 1 离开临界区
   生产者 2 准备进入临界区
   生产者 2 已进入临界区，生产产品 10
   生产者 2 将产品 10 存入缓冲区
   生产者 2 离开临界区
   消费者 1 准备进入临界区
   消费者 1 已进入临界区，取出产品 10
   消费者 1 消费产品 10
   消费者 1 离开临界区
   生产者 1 准备进入临界区
   生产者 1 已进入临界区，生产产品 11
   生产者 1 将产品 11 存入缓冲区
   生产者 1 离开临界区
   消费者 2 准备进入临界区
   消费者 2 已进入临界区，取出产品 11
   消费者 2 消费产品 11
   消费者 2 离开临界区
   生产和消费过程结束。
   ```

   程序正常运行,没有出现死锁情况,输出内容合理

   使用测试案例进行测试:

   为了方便测试,修改代码:

   ```c++
   #include <iostream>
   #include <thread>
   #include <mutex>
   #include <condition_variable>
   #include <queue>
   #include <vector>
   #include <chrono>
   #include <random>
   
   using namespace std;
   
   int bufferSize;             // 缓冲区大小
   int maxProducts;            // 最大产品数量
   int productCounter = 0;     // 产品编号计数器
   
   mutex mtx;
   condition_variable cv_producer, cv_consumer;
   queue<int> buffer;          // 缓冲区队列
   
   // 随机数生成器
   random_device rd;
   mt19937 gen(rd());
   uniform_int_distribution<> dist(100, 500);
   
   void produce(int producerID) {
       while (true) {
           this_thread::sleep_for(chrono::milliseconds(dist(gen)));  // 模拟生产时间
   
           unique_lock<mutex> lock(mtx);
           cout << "生产者 " << producerID << " 准备进入临界区\n";
           cv_producer.wait(lock, [] { return buffer.size() < bufferSize; });
   
           // 检查是否已达到最大产品数量
           if (productCounter >= maxProducts) break;
   
           // 临界区 - 生产产品
           int productID = ++productCounter;
           cout << "生产者 " << producerID << " 已进入临界区，生产产品 " << productID << endl;
           
           // 将产品放入缓冲区
           buffer.push(productID);
           cout << "生产者 " << producerID << " 将产品 " << productID << " 存入缓冲区\n";
   
           cout << "生产者 " << producerID << " 离开临界区\n";
   
           cv_consumer.notify_all();  // 通知消费者
       }
   }
   
   void consume(int consumerID) {
       while (true) {
           this_thread::sleep_for(chrono::milliseconds(dist(gen)));  // 模拟消费时间
   
           unique_lock<mutex> lock(mtx);
           cout << "消费者 " << consumerID << " 准备进入临界区\n";
           cv_consumer.wait(lock, [] { return !buffer.empty() || productCounter >= maxProducts; });
   
           // 检查缓冲区是否为空且已达到最大产品数量
           if (buffer.empty() && productCounter >= maxProducts) break;
   
           // 临界区 - 消费产品
           int productID = buffer.front();
           buffer.pop();
           cout << "消费者 " << consumerID << " 已进入临界区，取出产品 " << productID << endl;
   
           cout << "消费者 " << consumerID << " 消费产品 " << productID << endl;
           cout << "消费者 " << consumerID << " 离开临界区\n";
   
           cv_producer.notify_all();  // 通知生产者
       }
   }
   
   int main() {
       // 参数设置
       int numProducers, numConsumers;
   
       cout << "请输入生产者数量: ";
       cin >> numProducers;
       cout << "请输入消费者数量: ";
       cin >> numConsumers;
       cout << "请输入产品总数: ";
       cin >> maxProducts;
       cout << "请输入缓冲区大小: ";
       cin >> bufferSize;
   
       // 边界条件处理
       if (maxProducts == 0) {
           cout << "产品总数为0，无需生产或消费。" << endl;
           return 0;
       }
       if (numProducers == 0 && numConsumers > 0) {
           cout << "没有生产者，消费者无法消费任何产品。" << endl;
           return 0;
       }
       if (numConsumers == 0 && numProducers > 0) {
           cout << "没有消费者，所有产品将被生产后丢弃。" << endl;
           return 0;
       }
       if (numProducers == 0 && numConsumers == 0) {
           cout << "没有生产者和消费者，无需执行任何操作。" << endl;
           return 0;
       }
   
       // 创建生产者线程
       vector<thread> producers;
       for (int i = 1; i <= numProducers; ++i) {
           producers.emplace_back(produce, i);
       }
   
       // 创建消费者线程
       vector<thread> consumers;
       for (int i = 1; i <= numConsumers; ++i) {
           consumers.emplace_back(consume, i);
       }
   
       // 等待所有生产者线程完成
       for (auto& p : producers) {
           if (p.joinable()) p.join();
       }
   
       // 等待所有消费者线程完成
       for (auto& c : consumers) {
           if (c.joinable()) c.join();
       }
   
       cout << "生产和消费过程结束。" << endl;
       return 0;
   }
   ```

   1. 2 个生产者；3 个消费者；15 个产品；缓冲区大小为 4 

      ```c++
      请输入生产者数量: 2
      请输入消费者数量: 3
      请输入产品总数: 15
      请输入缓冲区大小: 4
      消费者 3 准备进入临界区
      生产者 1 准备进入临界区
      生产者 1 已进入临界区，生产产品 1
      生产者 1 将产品 1 存入缓冲区
      生产者 1 离开临界区
      消费者 3 已进入临界区，取出产品 1
      消费者 3 消费产品 1
      消费者 3 离开临界区
      消费者 1 准备进入临界区
      生产者 2 准备进入临界区
      生产者 2 已进入临界区，生产产品 2
      生产者 2 将产品 2 存入缓冲区
      生产者 2 离开临界区
      消费者 1 已进入临界区，取出产品 2
      消费者 1 消费产品 2
      消费者 1 离开临界区
      消费者 2 准备进入临界区
      生产者 1 准备进入临界区
      生产者 1 已进入临界区，生产产品 3
      生产者 1 将产品 3 存入缓冲区
      生产者 1 离开临界区
      消费者 2 已进入临界区，取出产品 3
      消费者 2 消费产品 3
      消费者 2 离开临界区
      消费者 3 准备进入临界区
      消费者 1 准备进入临界区
      生产者 2 准备进入临界区
      生产者 2 已进入临界区，生产产品 4
      生产者 2 将产品 4 存入缓冲区
      生产者 2 离开临界区
      消费者 1 已进入临界区，取出产品 4
      消费者 1 消费产品 4
      消费者 1 离开临界区
      消费者 2 准备进入临界区
      消费者 1 准备进入临界区
      生产者 1 准备进入临界区
      生产者 1 已进入临界区，生产产品 5
      生产者 1 将产品 5 存入缓冲区
      生产者 1 离开临界区
      消费者 2 已进入临界区，取出产品 5
      消费者 2 消费产品 5
      消费者 2 离开临界区
      生产者 2 准备进入临界区
      生产者 2 已进入临界区，生产产品 6
      生产者 2 将产品 6 存入缓冲区
      生产者 2 离开临界区
      消费者 3 已进入临界区，取出产品 6
      消费者 3 消费产品 6
      消费者 3 离开临界区
      消费者 2 准备进入临界区
      生产者 2 准备进入临界区
      生产者 2 已进入临界区，生产产品 7
      生产者 2 将产品 7 存入缓冲区
      生产者 2 离开临界区
      消费者 2 已进入临界区，取出产品 7
      消费者 2 消费产品 7
      消费者 2 离开临界区
      生产者 1 准备进入临界区
      生产者 1 已进入临界区，生产产品 8
      生产者 1 将产品 8 存入缓冲区
      生产者 1 离开临界区
      消费者 1 已进入临界区，取出产品 8
      消费者 1 消费产品 8
      消费者 1 离开临界区
      消费者 3 准备进入临界区
      生产者 1 准备进入临界区
      生产者 1 已进入临界区，生产产品 9
      生产者 1 将产品 9 存入缓冲区
      生产者 1 离开临界区
      消费者 3 已进入临界区，取出产品 9
      消费者 3 消费产品 9
      消费者 3 离开临界区
      消费者 2 准备进入临界区
      生产者 2 准备进入临界区
      生产者 2 已进入临界区，生产产品 10
      生产者 2 将产品 10 存入缓冲区
      生产者 2 离开临界区
      消费者 2 已进入临界区，取出产品 10
      消费者 2 消费产品 10
      消费者 2 离开临界区
      消费者 1 准备进入临界区
      生产者 2 准备进入临界区
      生产者 2 已进入临界区，生产产品 11
      生产者 2 将产品 11 存入缓冲区
      生产者 2 离开临界区
      消费者 1 已进入临界区，取出产品 11
      消费者 1 消费产品 11
      消费者 1 离开临界区
      消费者 2 准备进入临界区
      生产者 1 准备进入临界区
      生产者 1 已进入临界区，生产产品 12
      生产者 1 将产品 12 存入缓冲区
      生产者 1 离开临界区
      消费者 2 已进入临界区，取出产品 12
      消费者 2 消费产品 12
      消费者 2 离开临界区
      消费者 3 准备进入临界区
      消费者 1 准备进入临界区
      生产者 2 准备进入临界区
      生产者 2 已进入临界区，生产产品 13
      生产者 2 将产品 13 存入缓冲区
      生产者 2 离开临界区
      消费者 1 已进入临界区，取出产品 13
      消费者 1 消费产品 13
      消费者 1 离开临界区
      生产者 1 准备进入临界区
      生产者 1 已进入临界区，生产产品 14
      生产者 1 将产品 14 存入缓冲区
      生产者 1 离开临界区
      消费者 3 已进入临界区，取出产品 14
      消费者 3 消费产品 14
      消费者 3 离开临界区
      生产者 2 准备进入临界区
      生产者 2 已进入临界区，生产产品 15
      生产者 2 将产品 15 存入缓冲区
      生产者 2 离开临界区
      消费者 1 准备进入临界区
      消费者 1 已进入临界区，取出产品 15
      消费者 1 消费产品 15
      消费者 1 离开临界区
      消费者 2 准备进入临界区
      生产者 1 准备进入临界区
      消费者 3 准备进入临界区
      生产者 2 准备进入临界区
      消费者 1 准备进入临界区
      生产和消费过程结束。
      ```

   2. 0 个生产者；3 个消费者；15 个产品；缓冲区大小为 4 

      ```c++
      请输入生产者数量: 0
      请输入消费者数量: 3
      请输入产品总数: 15
      请输入缓冲区大小: 4
      没有生产者，消费者无法消费任何产品。
      ```

   3. 2 个生产者；0 个消费者；15 个产品；缓冲区大小为 4

      ```c++
      请输入生产者数量: 2
      请输入消费者数量: 0
      请输入产品总数: 15
      请输入缓冲区大小: 4
      没有消费者，所有产品将被生产后丢弃。
      ```

   4. 2 个生产者；3 个消费者；15 个产品；缓冲区大小为 1

      ```c++
      请输入生产者数量: 2
      请输入消费者数量: 3
      请输入产品总数: 15
      请输入缓冲区大小: 1
      消费者 2 准备进入临界区
      消费者 3 准备进入临界区
      消费者 1 准备进入临界区
      生产者 1 准备进入临界区
      生产者 1 已进入临界区，生产产品 1
      生产者 1 将产品 1 存入缓冲区
      生产者 1 离开临界区
      消费者 3 已进入临界区，取出产品 1
      消费者 3 消费产品 1
      消费者 3 离开临界区
      生产者 2 准备进入临界区
      生产者 2 已进入临界区，生产产品 2
      生产者 2 将产品 2 存入缓冲区
      生产者 2 离开临界区
      消费者 1 已进入临界区，取出产品 2
      消费者 1 消费产品 2
      消费者 1 离开临界区
      消费者 3 准备进入临界区
      消费者 1 准备进入临界区
      生产者 1 准备进入临界区
      生产者 1 已进入临界区，生产产品 3
      生产者 1 将产品 3 存入缓冲区
      生产者 1 离开临界区
      消费者 2 已进入临界区，取出产品 3
      消费者 2 消费产品 3
      消费者 2 离开临界区
      生产者 2 准备进入临界区
      生产者 2 已进入临界区，生产产品 4
      生产者 2 将产品 4 存入缓冲区
      生产者 2 离开临界区
      消费者 3 已进入临界区，取出产品 4
      消费者 3 消费产品 4
      消费者 3 离开临界区
      生产者 2 准备进入临界区
      生产者 2 已进入临界区，生产产品 5
      生产者 2 将产品 5 存入缓冲区
      生产者 2 离开临界区
      消费者 1 已进入临界区，取出产品 5
      消费者 1 消费产品 5
      消费者 1 离开临界区
      消费者 3 准备进入临界区
      消费者 2 准备进入临界区
      生产者 1 准备进入临界区
      生产者 1 已进入临界区，生产产品 6
      生产者 1 将产品 6 存入缓冲区
      生产者 1 离开临界区
      消费者 3 已进入临界区，取出产品 6
      消费者 3 消费产品 6
      消费者 3 离开临界区
      生产者 2 准备进入临界区
      生产者 2 已进入临界区，生产产品 7
      生产者 2 将产品 7 存入缓冲区
      生产者 2 离开临界区
      消费者 2 已进入临界区，取出产品 7
      消费者 2 消费产品 7
      消费者 2 离开临界区
      消费者 1 准备进入临界区
      消费者 3 准备进入临界区
      生产者 1 准备进入临界区
      生产者 1 已进入临界区，生产产品 8
      生产者 1 将产品 8 存入缓冲区
      生产者 1 离开临界区
      消费者 1 已进入临界区，取出产品 8
      消费者 1 消费产品 8
      消费者 1 离开临界区
      生产者 2 准备进入临界区
      生产者 2 已进入临界区，生产产品 9
      生产者 2 将产品 9 存入缓冲区
      生产者 2 离开临界区
      消费者 3 已进入临界区，取出产品 9
      消费者 3 消费产品 9
      消费者 3 离开临界区
      消费者 2 准备进入临界区
      生产者 1 准备进入临界区
      生产者 1 已进入临界区，生产产品 10
      生产者 1 将产品 10 存入缓冲区
      生产者 1 离开临界区
      消费者 2 已进入临界区，取出产品 10
      消费者 2 消费产品 10
      消费者 2 离开临界区
      消费者 1 准备进入临界区
      生产者 1 准备进入临界区
      生产者 1 已进入临界区，生产产品 11
      生产者 1 将产品 11 存入缓冲区
      生产者 1 离开临界区
      消费者 1 已进入临界区，取出产品 11
      消费者 1 消费产品 11
      消费者 1 离开临界区
      生产者 2 准备进入临界区
      生产者 2 已进入临界区，生产产品 12
      生产者 2 将产品 12 存入缓冲区
      生产者 2 离开临界区
      消费者 2 准备进入临界区
      消费者 2 已进入临界区，取出产品 12
      消费者 2 消费产品 12
      消费者 2 离开临界区
      消费者 3 准备进入临界区
      生产者 2 准备进入临界区
      生产者 2 已进入临界区，生产产品 13
      生产者 2 将产品 13 存入缓冲区
      生产者 2 离开临界区
      消费者 3 已进入临界区，取出产品 13
      消费者 3 消费产品 13
      消费者 3 离开临界区
      生产者 1 准备进入临界区
      生产者 1 已进入临界区，生产产品 14
      生产者 1 将产品 14 存入缓冲区
      生产者 1 离开临界区
      消费者 1 准备进入临界区
      消费者 1 已进入临界区，取出产品 14
      消费者 1 消费产品 14
      消费者 1 离开临界区
      消费者 2 准备进入临界区
      生产者 1 准备进入临界区
      生产者 1 已进入临界区，生产产品 15
      生产者 1 将产品 15 存入缓冲区
      生产者 1 离开临界区
      消费者 2 已进入临界区，取出产品 15
      消费者 2 消费产品 15
      消费者 2 离开临界区
      生产者 2 准备进入临界区
      消费者 1 准备进入临界区
      消费者 2 准备进入临界区
      消费者 3 准备进入临界区
      生产者 1 准备进入临界区
      生产和消费过程结束。
      ```

   5. 0 个生产者；0 个消费者；15 个产品；缓冲区大小为 4

      ```c++
      请输入生产者数量: 0
      请输入消费者数量: 0
      请输入产品总数: 15
      请输入缓冲区大小: 4
      没有生产者和消费者，无需执行任何操作。
      ```

   6. 2 个生产者；3 个消费者；0 个产品；缓冲区大小为 4 

      ```c++
      请输入生产者数量: 2
      请输入消费者数量: 3
      请输入产品总数: 0
      请输入缓冲区大小: 4
      产品总数为0，无需生产或消费。
      ```

4. 实验心得体会

   1. **编写代码并添加边界检查**：
      - 将C++代码保存为`producer_consumer.cpp`。
      - 在代码中加入边界检查：
        - 如果产品总数为0，程序输出提示信息并直接退出。
        - 如果没有生产者但有消费者，程序输出提示，说明消费者无法消费任何产品，并退出。
        - 如果没有消费者但有生产者，程序输出提示，说明产品将被生产后丢弃，并退出。
        - 如果生产者和消费者都没有，程序输出提示，说明无需执行操作，并退出。
   2. **编译代码**：
      - 使用`g++`编译代码，生成可执行文件。
   3. **运行代码并输入测试参数**：
      - 运行可执行文件，按照要求输入生产者数量、消费者数量、产品总数、缓冲区大小。
      - 根据不同测试用例输入相应参数，以验证边界条件和正常生产消费过程。
   4. **验证输出**：
      - 检查程序输出，确保在满足或触发各类边界条件时程序的行为符合预期：
        - 在有消费者但没有生产者的情况下，程序应提示“没有生产者，消费者无法消费任何产品”并退出。
        - 在有生产者但没有消费者的情况下，程序应提示“没有消费者，所有产品将被生产后丢弃”并退出。
        - 其他情况下，程序应正常执行生产和消费过程，并输出详细的状态信息，包括进入临界区、生产或消费产品、存入或取出缓冲区等步骤。

   通过这些步骤，可以有效验证程序在不同生产者、消费者和产品设置下的正确性和稳定性。

   ####  总结与反思

   这次实验让我意识到理论知识与实践的重要性，实际操作能让我更好地理解和应用所学知识。在今后的学习中，我希望能够继续实践，探索更多的计算机系统编程技术。

   

   总的来说，这次实验不仅提升了我的编程技能，也增强了我对操作系统编程的兴趣和热情







